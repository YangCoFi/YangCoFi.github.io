{"meta":{"title":"阿yang","subtitle":null,"description":"Every day is a chance to learn something new.","author":"YangCoFi","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"俄罗斯信封问题","slug":"RussianDollEnvelopes","date":"2019-06-30T08:44:09.350Z","updated":"2019-06-30T11:31:07.075Z","comments":true,"path":"2019/06/30/RussianDollEnvelopes/","link":"","permalink":"http://yoursite.com/2019/06/30/RussianDollEnvelopes/","excerpt":"","text":"俄罗斯信封问题问题描述 如：给信封[[5,4],[6,4],[6,7],[2,3]]，最大的值为3([2,3] =&gt; [5,4] =&gt; [6,7])必须w和h都比另一个大才行 w相等或h相等都不行！！ 思路 假定所有的信封的长度和宽度都是不重复的 将这些信封按照w从小到大排序，此时h会组成一个数组，在这个h组成的数组上找最长递增子序列，解决。 如果是可以相等，如何解决？ 将w按照递增进行排序 再将每一个w相应的h从大到小进行排序。 代码public class Problem_02_RussianDollEnvelopes { public static class Dot { public int w; public int h; public Dot(int weight, int hight) { w = weight; h = hight; } } public static class DotComparator implements Comparator&lt;Dot&gt; { @Override public int compare(Dot arg0, Dot arg1) { if (arg0.w != arg1.w) { return arg0.w - arg1.w; } else { return arg1.h - arg0.h; } } } public static int maxEnvelopes(int[][] es) { if (es == null || es.length == 0 || es[0] == null || es[0].length != 2) { return 0; } Dot[] dots = new Dot[es.length]; for (int i = 0; i &lt; es.length; i++) { dots[i] = new Dot(es[i][0], es[i][1]); } Arrays.sort(dots, new DotComparator()); int[] ends = new int[es.length]; ends[0] = dots[0].h; int right = 0; int l = 0; int r = 0; int m = 0; for (int i = 1; i &lt; dots.length; i++) { l = 0; r = right; while (l &lt;= r) { m = (l + r) / 2; if (dots[i].h &gt; ends[m]) { l = m + 1; } else { r = m - 1; } } right = Math.max(right, l); ends[l] = dots[i].h; } return right + 1; } public static void main(String[] args) { int[][] test = { { 4, 3 }, { 1, 2 }, { 5, 7 }, { 5, 3 }, { 1, 1 }, { 4, 9 } }; System.out.println(maxEnvelopes(test)); } }","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"最长递增子序列问题","slug":"最长递增子序列问题","date":"2019-06-30T06:42:24.830Z","updated":"2019-06-30T08:23:09.262Z","comments":true,"path":"2019/06/30/最长递增子序列问题/","link":"","permalink":"http://yoursite.com/2019/06/30/最长递增子序列问题/","excerpt":"","text":"#最长递增子序列问题 问题描述如3 1 2 5 4 6 7 最长子序列是1 2 5 6 7或者是1 2 4 6 7 子序列是可以不连续的，子数组必须是连续的。 返回5 思路经典解法准备一个数组arr，这个数组和原数组一样长，这个数组记着是数组中如果必须要以某个数结尾的情况下最长递增子序列的长度。如[3 1 2 5 4 6 7]，他的arr数组为[1 1 2 3 3 4 5],从左往右，以3结尾的递增子序列就是它自己，所以arr数组0位置为1；对于1来说，左边的数都不比1小，所以他只能自己构成一个递增子序列，所以它的长度还是1；再看2，左边比它小的数，找到了一个1，因为以1作为结尾的最长子序列是1，而2在1的右边，所以2对应的arr数组上的数为2。对于5来说，找左边所有比它小的，再从所有比它小的数里面找相应的arr数组对应的最大的数，而5可以落在它之后，以2为结尾的最长递增子序列是最长的，为2，所以5对应的arr数组上的相应位置为3。以此类推。 我们发现arr左边求得的信息是可以帮助我们求得右边的位置的值的。所以我们最终要求的返回值就是arr数组中的最大值，我们将它返回就行。 问题：我们如果想还原最长的子序列的信息呢？怎么根据arr数组得到？ 现在数组为[3 1 2 5 4 6 7 1]，对应的arr数组[1 1 2 3 3 4 5 1]。找到一个序列过程：先在整个arr数组中找到最大值5，说明在原数组中相应位置上我一定是以这个数结尾的。通过原数组得到这个数，为7，下面我开始在原数组找比7小并且是5-1=4的那个数，就是6，说明倒数倒数第二个数是6，在原数组找比6小并且是4-1=3的那个数。以此类推。 因为我在每个位置去求这个值的时候，左边最差要遍历一遍。所以时间复杂度为o(n2)。 优化解法出发点：能不能每次遍历到这个位置上的时候，想求这个位置上的数必须以它结尾的情况下的最长递增子序列，这个过程能不能不遍历呢？ 数组[3 1 2 4 3]，有效区和无效区。ends[3 N N N N] ends(i)的意义：长度为i+1的所有递增子序列中最小结尾是什么。 有效区：就是ends数组里面此时有数的区域。 一开始你遍历到0位置，就是3，ends[0]就代表遍历到当前0位置时长度为1的所有递增子序列中最小结尾是3。再来一个len数组，记录长度。len：[1 N N N N]，再继续遍历到1，有效区再怎么更新呢？以二分的方式在有效区里面找哪个是第一个比它大的。它找到了3，因此将ends[0]更新，把3更新成1,ends[1 N N N N].代表我遍历到1这个位置为止，所有长度为1的递增子序列的最小结尾是1。怎么确定以1结尾的情况下它的最长递增子序列长度是多少呢？同样，在这个ends数组中1左边有数吗？没有。OK，它的长度就是1。len:[1 1 N N N]。 此时数组遍历到了2这个数，在有效区以二分的方式去找比他大的数，没找到，OK。有效区扩充 ends:[1 2 N N N]。2代表着遍历到此时为止所有长度为2的递增子序列的最小结尾是2。在ends中，2左边有1个数，可以组成的长度为2，所以在len中相应位置就是2。len:[1 1 2 N N]，OK，再看4，4又去有效区二分找，发现找不到刚比它大的，有效区扩充。ends：[1 2 4 N N]，在ends中4左边有两个数，它能够组成多长的递增子序列？3。len：[1 1 2 3 N]。好，最后来到了原数组的最后一位，数为3，它以二分的方式找到了ends中刚比他大的，找到了4，所以就把4改成了3，代表遍历到此时为止长度为3的递增子序列的最小结尾是3，ends：[1 2 3 N N]，3的左边有两个数，于是以3结尾的最长递增子序列的长度是3。len：[1 1 2 3 3 3]。这就是我们最终的得到的长度数组。 有效区肯定是递增的。 在一个有序数组中，找到一个数刚比他大，这个行为是可以二分的。 代码 public class Problem_01_LIS { public static int[] lis1(int[] arr) { if (arr == null || arr.length == 0) { return null; } int[] dp = getdp1(arr); return generateLIS(arr, dp); } public static int[] getdp1(int[] arr) { int[] dp = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) { dp[i] = 1; for (int j = 0; j &lt; i; j++) { if (arr[i] &gt; arr[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } } return dp; } public static int[] generateLIS(int[] arr, int[] dp) { int len = 0; int index = 0; for (int i = 0; i &lt; dp.length; i++) { if (dp[i] &gt; len) { len = dp[i]; index = i; } } int[] lis = new int[len]; lis[--len] = arr[index]; for (int i = index; i &gt;= 0; i--) { if (arr[i] &lt; arr[index] &amp;&amp; dp[i] == dp[index] - 1) { lis[--len] = arr[i]; index = i; } } return lis; } public static int[] lis2(int[] arr) { if (arr == null || arr.length == 0) { return null; } int[] dp = getdp2(arr); return generateLIS(arr, dp); } public static int[] getdp2(int[] arr) { int[] dp = new int[arr.length]; int[] ends = new int[arr.length]; ends[0] = arr[0]; dp[0] = 1; int right = 0; int l = 0; int r = 0; int m = 0; for (int i = 1; i &lt; arr.length; i++) { l = 0; r = right; while (l &lt;= r) { m = (l + r) / 2; if (arr[i] &gt; ends[m]) { l = m + 1; } else { r = m - 1; } } right = Math.max(right, l); ends[l] = arr[i]; dp[i] = l + 1; } return dp; } // for test public static void printArray(int[] arr) { for (int i = 0; i != arr.length; i++) { System.out.print(arr[i] + &quot; &quot;); } System.out.println(); } public static void main(String[] args) { int[] arr = { 2, 1, 5, 3, 6, 4, 8, 9, 7 }; printArray(arr); printArray(lis1(arr)); printArray(lis2(arr)); } }","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"商城秒杀系统-分布式session","slug":"商城秒杀系统笔记","date":"2019-06-30T04:24:55.726Z","updated":"2019-06-30T08:44:29.935Z","comments":true,"path":"2019/06/30/商城秒杀系统笔记/","link":"","permalink":"http://yoursite.com/2019/06/30/商城秒杀系统笔记/","excerpt":"","text":"转载至 https://blog.csdn.net/Brad_PiTt7/article/details/90635659 ##综述我们的秒杀服务，实际的应用可能不止部署在一个服务器上，而是分布式的多台服务器，这时候假如用户登录是在第一个服务器，第一个请求到了第一台服务器，但是第二个请求到了第二个服务器，那么用户的session信息就丢失了。 public class GoodsController { @Autowired SeckillUserService seckillUserService; @Autowired RedisService redisService; @RequestMapping(&quot;/to_list&quot;) public String to_list() }","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]}